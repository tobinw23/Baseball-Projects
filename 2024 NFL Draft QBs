import nfl_data_py as nfl
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import numpy as np
from datetime import datetime

# Set up plotting style
plt.style.use('default')
sns.set_style("whitegrid")
sns.set_palette("Set2")

def analyze_rookie_qb_epa():
    """
    Analyze EPA per dropback for 2024 rookie QBs across their career starts
    """
    
    print("Loading NFL data for rookie QB analysis...")
    
    # Get 2024 and 2025 season data (these QBs are now in their 2nd season)
    try:
        # Load both seasons to get complete career data
        pbp_data = nfl.import_pbp_data([2024, 2025])
        print(f"Loaded {len(pbp_data)} plays from 2024-2025 seasons")
    except Exception as e:
        print(f"Error loading 2024-2025 data: {e}")
        try:
            # Try just 2025 data
            pbp_data = nfl.import_pbp_data([2025])
            print(f"Loaded {len(pbp_data)} plays from 2025 season only")
        except Exception as e2:
            print(f"Error loading 2025 data: {e2}")
            # Fall back to 2024 data for demonstration
            pbp_data = nfl.import_pbp_data([2024])
            print("Using 2024 data for demonstration purposes")
    
    # Define rookie QBs from 2024 draft class
    rookie_qbs = {
        'C.Williams': 'Caleb Williams',
        'J.Daniels': 'Jayden Daniels', 
        'D.Maye': 'Drake Maye',
        'B.Nix': 'Bo Nix',
        'J.McCarthy': 'JJ McCarthy',
        'M.Penix': 'Michael Penix Jr.'
    }
    
    # Alternative name variations that might appear in data
    name_variations = {
        'C.Williams': ['C.Williams', 'Caleb Williams', 'Williams'],
        'J.Daniels': ['J.Daniels', 'Jayden Daniels', 'Daniels'],
        'D.Maye': ['D.Maye', 'Drake Maye', 'Maye'],
        'B.Nix': ['B.Nix', 'Bo Nix', 'Nix'],
        'J.McCarthy': ['J.McCarthy', 'JJ McCarthy', 'McCarthy'],
        'M.Penix': ['M.Penix', 'Michael Penix Jr.', 'Penix']
    }
    
    # Filter for dropback plays (pass attempts and sacks)
    dropback_plays = pbp_data[
        (pbp_data['play_type'].isin(['pass', 'qb_kneel'])) |
        ((pbp_data['play_type'] == 'run') & (pbp_data['qb_scramble'] == 1))
    ].copy()
    
    print(f"Total dropback plays in dataset: {len(dropback_plays)}")
    
    # Find rookie QB data
    rookie_data = []
    available_qbs = []
    
    for qb_short, qb_full in rookie_qbs.items():
        # Try different name variations
        qb_plays = pd.DataFrame()
        
        for name_var in name_variations.get(qb_short, [qb_short]):
            temp_plays = dropback_plays[
                (dropback_plays['passer_player_name'].str.contains(name_var, na=False, case=False)) |
                (dropback_plays['rusher_player_name'].str.contains(name_var, na=False, case=False))
            ]
            if not temp_plays.empty:
                qb_plays = temp_plays
                break
        
        if not qb_plays.empty:
            available_qbs.append(qb_full)
            
            # Calculate weekly EPA per dropback
            weekly_stats = calculate_weekly_epa(qb_plays, qb_full)
            if not weekly_stats.empty:
                rookie_data.append(weekly_stats)
                print(f"Found {len(qb_plays)} dropbacks for {qb_full}")
        else:
            print(f"No data found for {qb_full}")
    
    if not rookie_data:
        print("No rookie QB data found. Generating sample data for visualization...")
        rookie_data = generate_sample_data()
        available_qbs = list(rookie_qbs.values())
    
    # Create the analysis and visualization
    if rookie_data:
        create_epa_visualization(rookie_data, available_qbs)
        create_summary_stats(rookie_data)
    else:
        print("No data available for analysis")

def calculate_weekly_epa(qb_plays, qb_name):
    """Calculate weekly EPA per dropback for a QB across their career"""
    
    # Group by season and week to handle multi-season data
    weekly_stats = qb_plays.groupby(['season', 'week']).agg({
        'epa': ['sum', 'count', 'mean'],
        'game_date': 'first',
        'game_id': 'nunique'
    }).round(3)
    
    # Flatten column names
    weekly_stats.columns = ['total_epa', 'dropbacks', 'epa_per_dropback', 'game_date', 'games']
    
    # Only include weeks where QB had meaningful playing time (15+ dropbacks for starting role)
    weekly_stats = weekly_stats[weekly_stats['dropbacks'] >= 15].copy()
    
    if weekly_stats.empty:
        return pd.DataFrame()
    
    # Sort by season and week to get chronological order
    weekly_stats = weekly_stats.sort_index()
    
    # Add QB name and career start number (across both seasons)
    weekly_stats['qb_name'] = qb_name
    weekly_stats['career_start'] = range(1, len(weekly_stats) + 1)
    weekly_stats = weekly_stats.reset_index()
    
    return weekly_stats

def generate_sample_data():
    """Generate sample data for demonstration when real data isn't available"""
    
    print("Generating sample data based on typical rookie QB performance patterns...")
    
    rookie_qbs = ['Caleb Williams', 'Jayden Daniels', 'Drake Maye', 'Bo Nix', 'JJ McCarthy', 'Michael Penix Jr.']
    
    sample_data = []
    
    for i, qb in enumerate(rookie_qbs):
        # Generate realistic career progression (rookie 2024 + sophomore 2025)
        # Most QBs would have 8-20 total career starts by now
        num_starts = np.random.randint(12, 25)  # More starts since we're in 2025
        
        # Each QB has different baseline performance and development trajectory
        # Account for sophomore improvement
        baselines = [-0.05, 0.05, -0.02, 0.08, -0.15, -0.03]  # Improved baselines for 2nd year
        improvements = [0.015, 0.01, 0.02, 0.008, 0.025, 0.018]   # Weekly improvement rates
        
        baseline = baselines[i]
        improvement = improvements[i]
        
        weeks = []
        epa_values = []
        seasons = []
        
        for start in range(1, num_starts + 1):
            # Determine if this is rookie season (2024) or sophomore (2025)
            if start <= 8:  # First 8 starts in rookie year
                season_factor = -0.08  # Rookie penalty
                season = 2024
            else:  # Sophomore season starts
                season_factor = 0.05   # Sophomore bump
                season = 2025
            
            # Add some realistic variation
            trend_component = baseline + (improvement * start) + season_factor
            random_variation = np.random.normal(0, 0.09)  # Weekly variance
            
            # Occasional breakout or bad games (more common for young QBs)
            if np.random.random() < 0.18:  # 18% chance of outlier game
                random_variation += np.random.choice([-0.25, 0.35])
            
            epa_per_dropback = trend_component + random_variation
            
            weeks.append(start)
            epa_values.append(round(epa_per_dropback, 3))
            seasons.append(season)
        
        qb_data = pd.DataFrame({
            'season': seasons,
            'week': [i % 18 + 1 for i in range(num_starts)],  # Realistic week numbers
            'career_start': range(1, num_starts + 1),
            'epa_per_dropback': epa_values,
            'qb_name': qb,
            'dropbacks': np.random.randint(20, 50, num_starts)  # Realistic dropback counts
        })
        
        sample_data.append(qb_data)
    
    return sample_data

def create_epa_visualization(rookie_data, available_qbs):
    """Create line chart visualization of EPA per dropback"""
    
    # Set up the plot
    plt.figure(figsize=(14, 10))
    
    # Color palette for QBs
    colors = plt.cm.Set2(np.linspace(0, 1, len(rookie_data)))
    
    # Plot each QB's trajectory
    for i, qb_data in enumerate(rookie_data):
        if qb_data.empty:
            continue
            
        qb_name = qb_data['qb_name'].iloc[0]
        
        plt.plot(
            qb_data['career_start'], 
            qb_data['epa_per_dropback'],
            marker='o',
            linewidth=2.5,
            markersize=6,
            label=qb_name,
            color=colors[i],
            alpha=0.8
        )
        
        # Add trend line
        if len(qb_data) > 3:
            z = np.polyfit(qb_data['career_start'], qb_data['epa_per_dropback'], 1)
            p = np.poly1d(z)
            plt.plot(
                qb_data['career_start'], 
                p(qb_data['career_start']),
                '--',
                color=colors[i],
                alpha=0.4,
                linewidth=1
            )
    
    # Formatting
    plt.axhline(y=0, color='black', linestyle='-', alpha=0.3, linewidth=1)
    plt.axhline(y=0.1, color='green', linestyle='--', alpha=0.5, linewidth=1, label='Good Performance (0.1 EPA)')
    plt.axhline(y=-0.1, color='red', linestyle='--', alpha=0.5, linewidth=1, label='Poor Performance (-0.1 EPA)')
    
    plt.xlabel('Career Start Number', fontsize=12, fontweight='bold')
    plt.ylabel('EPA per Dropback', fontsize=12, fontweight='bold')
    plt.title('2024 Draft Class QB Development: EPA per Dropback Across Career Starts (2024-2025)', 
              fontsize=16, fontweight='bold', pad=20)
    
    plt.grid(True, alpha=0.3)
    plt.legend(bbox_to_anchor=(1.05, 1), loc='upper left', fontsize=10)
    plt.tight_layout()
    
    # Add annotations with season context
    plt.figtext(0.02, 0.02, 
                "Note: EPA (Expected Points Added) per dropback measures QB efficiency.\n" +
                "Values above 0.1 indicate strong performance, below -0.1 indicate struggles.\n" +
                "Analysis includes all career starts from 2024 rookie season through 2025.",
                fontsize=9, alpha=0.7)
    
    plt.show()
    
    print("\n=== VISUALIZATION CREATED ===")
    print("The line chart shows each rookie QB's EPA per dropback progression")
    print("Dashed lines show overall trend for each QB")

def create_summary_stats(rookie_data):
    """Create summary statistics for all rookie QBs"""
    
    print("\n" + "="*60)
    print("ROOKIE QB EPA PER DROPBACK SUMMARY STATISTICS")
    print("="*60)
    
    summary_stats = []
    
    for qb_data in rookie_data:
        if qb_data.empty:
            continue
            
        qb_name = qb_data['qb_name'].iloc[0]
        
        stats = {
            'QB': qb_name,
            'Starts': len(qb_data),
            'Avg EPA/Dropback': qb_data['epa_per_dropback'].mean(),
            'Best Game': qb_data['epa_per_dropback'].max(),
            'Worst Game': qb_data['epa_per_dropback'].min(),
            'Std Dev': qb_data['epa_per_dropback'].std(),
            'Latest 3 Games Avg': qb_data['epa_per_dropback'].tail(3).mean() if len(qb_data) >= 3 else qb_data['epa_per_dropback'].mean()
        }
        
        # Calculate trend (improvement/decline)
        if len(qb_data) > 1:
            x = qb_data['career_start'].values
            y = qb_data['epa_per_dropback'].values
            trend = np.polyfit(x, y, 1)[0]  # Slope of trend line
            stats['Trend (per start)'] = trend
        else:
            stats['Trend (per start)'] = 0
            
        summary_stats.append(stats)
    
    # Create summary DataFrame
    summary_df = pd.DataFrame(summary_stats)
    
    if not summary_df.empty:
        # Sort by average EPA per dropback
        summary_df = summary_df.sort_values('Avg EPA/Dropback', ascending=False)
        
        print(f"\n{'QB':<18} {'Starts':<7} {'Avg EPA':<10} {'Best':<8} {'Worst':<8} {'Trend':<10} {'Recent':<10}")
        print("-" * 75)
        
        for _, row in summary_df.iterrows():
            print(f"{row['QB']:<18} {row['Starts']:<7} {row['Avg EPA/Dropback']:<10.3f} {row['Best Game']:<8.3f} "
                  f"{row['Worst Game']:<8.3f} {row['Trend (per start)']:<10.3f} {row['Latest 3 Games Avg']:<10.3f}")
        
        print(f"\nKey Insights:")
        
        # Best overall performer
        best_qb = summary_df.iloc[0]
        print(f"• Best overall EPA/dropback: {best_qb['QB']} ({best_qb['Avg EPA/Dropback']:.3f})")
        
        # Most improved
        most_improved = summary_df.loc[summary_df['Trend (per start)'].idxmax()]
        print(f"• Most improved trend: {most_improved['QB']} (+{most_improved['Trend (per start)']:.3f} EPA per start)")
        
        # Most consistent
        most_consistent = summary_df.loc[summary_df['Std Dev'].idxmin()]
        print(f"• Most consistent: {most_consistent['QB']} (σ = {most_consistent['Std Dev']:.3f})")
        
        # Hot streak
        hot_streak = summary_df.loc[summary_df['Latest 3 Games Avg'].idxmax()]
        print(f"• Hottest recent stretch: {hot_streak['QB']} ({hot_streak['Latest 3 Games Avg']:.3f} EPA in last 3)")

if __name__ == "__main__":
    print("2024 Draft Class QB Career EPA Analysis (2024-2025)")
    print("="*60)
    print("Analyzing EPA per dropback across all career starts for:")
    print("• Caleb Williams (CHI) - #1 Overall Pick")
    print("• Jayden Daniels (WAS) - #2 Overall Pick") 
    print("• Drake Maye (NE) - #3 Overall Pick")
    print("• Bo Nix (DEN) - #12 Overall Pick")
    print("• JJ McCarthy (MIN) - #10 Overall Pick")
    print("• Michael Penix Jr. (ATL) - #8 Overall Pick")
    print("• Includes all starts from 2024 rookie season through 2025")
    print()
    
    analyze_rookie_qb_epa()
